### Задача 1

Список операций, для остановки запроса пользователя:

1. Вывел бы список запущенных операций для оперделения проблемной операции командой db.currentOp().
2. Завершил операцию командой db.killOp(<opId>).

Варианты решения проблемы с долгими (зависающими) запросами в MongoDB:

1. Воспользовался бы системой профилирования Database Profiler, для поиска медленных операции;
2. С помощью executionStats проанализировал их;
3. Попробовал оптимизировать;
4. Добавил/удалил индексы, настроил шардинг.

### Задача 2

Одна из причин это память которая могла заполниться истекшими ключами, которые еще не удалены окончательно, по этому Redis мог заблокировался, чтобы вывести из db удаленные ключи и снизить их количество.
Так как Redis однопоточное приложение, то все операции блокируются, пока он не выполнит очистку.

https://redis.io/docs/management/optimization/latency/#latency-generated-by-expires
Basically this means that if the database has many, many keys expiring in the same second, and these make up at least 25% of the current population of keys with an expire set, Redis can block in order to get the percentage of keys already expired below 25%.
В основном это означает, что если в базе данных много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% от текущей совокупности ключей с истекающим набором Redis может блокировать, чтобы процент ключей, срок действия которых уже истек, был ниже 25%.
Как указано в документации этот подход необходим для того, чтобы избежать использования слишком большого объема памяти для ключей, срок действия которых уже истек.

### Задача 3

Возможно проблема связана из-за большого колличества записей в таблице, по этому запрос не успевает обработаться до таймаута.

1. Попробовал бы увеличить параметры таймаутов:
connect_timeout;
wait_timeout;
interactive_timeout;
net_read_timeout.

2. Добавл бы ресурсов на машине где была развернута база данных MySQL.

### Задача 4

Из за высокого потребления оперативной памяти процессом PostgreSQL, ее становиться не достаточно и как результат происходит завершение процесса ядром ОС.
Для решения данной проблемы нужно установить ограничение на потребление памяти процессами PostgreSQL подобрав оптимальные значения work_mem, shared_buffers, temp_buffers, effective_cache_size, maintenance_work_mem.

